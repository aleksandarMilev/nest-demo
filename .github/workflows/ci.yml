name: CI/CD Pipeline

on:
  pull_request:
    branches: [ master ]
  push:
    branches: [ master ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: "Force AWS deploy even if not a push to master?"
        required: false
        default: "false"

jobs:
  build-test-deploy:
    runs-on: ubuntu-latest

    env:
      AWS_REGION: eu-north-1
      EB_APP_NAME: "nest demo"
      EB_ENV_NAME: "Nestdemo-env"
      ECR_REPO: "nest-demo"
      IMAGE_TAG: ${{ github.sha }}

      AWS_ACCESS_KEY: ${{ secrets.AWS_ACCESS_KEY }}
      AWS_SECRET_KEY: ${{ secrets.AWS_SECRET_KEY }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image for testing
        run: docker build -t aleksandarMilev/nest-demo -f Dockerfile.dev .

      - name: Create test env file
        run: |
          cp .env.example .env.dev
          sed -i 's/^NODE_ENV=.*/NODE_ENV=test/' .env.dev
          sed -i 's|^DATABASE_URL=.*|DATABASE_URL=postgres://user:pass@localhost:5432/ci|' .env.dev

      - name: Run Jest tests
        run: docker run --env-file .env.dev -e CI=true aleksandarMilev/nest-demo npm run test:cov

      - name: Configure AWS credentials (if secrets exist)
        id: awscreds
        if: ${{ env.AWS_ACCESS_KEY != '' && env.AWS_SECRET_KEY != '' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ env.AWS_SECRET_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: "Preflight check: can_deploy?"
        id: can_deploy
        shell: bash
        run: |
          set -e
          echo "should=false" >> $GITHUB_OUTPUT

          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/master" ]] || [[ "${{ inputs.force_deploy }}" == "true" ]]; then
            :
          else
            echo "Not a deploy event (push to master) and force_deploy not set."
            exit 0
          fi

          if [[ "${{ steps.awscreds.outcome }}" != "success" ]]; then
            echo "AWS credentials not configured; skipping deploy."
            exit 0
          fi

          if aws elasticbeanstalk describe-applications --application-names "${EB_APP_NAME}" >/dev/null 2>&1; then
            if aws elasticbeanstalk describe-environments --application-name "${EB_APP_NAME}" \
                 --environment-names "${EB_ENV_NAME}" --no-include-deleted >/dev/null 2>&1; then
              echo "should=true" >> $GITHUB_OUTPUT
              echo "Beanstalk app/env found; enabling deploy."
            else
              echo "Beanstalk environment '${EB_ENV_NAME}' not found; skipping deploy."
            fi
          else
            echo "Beanstalk application '${EB_APP_NAME}' not found; skipping deploy."
          fi

      - name: Get AWS account ID
        if: ${{ steps.can_deploy.outputs.should == 'true' }}
        id: acct
        run: echo "id=$(aws sts get-caller-identity --query Account --output text)" >> $GITHUB_OUTPUT

      - name: Ensure ECR repository exists
        if: ${{ steps.can_deploy.outputs.should == 'true' }}
        run: |
          aws ecr describe-repositories --repository-names "${ECR_REPO}" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name "${ECR_REPO}" >/dev/null

      - name: Log in to ECR
        if: ${{ steps.can_deploy.outputs.should == 'true' }}
        run: |
          aws ecr get-login-password --region "${AWS_REGION}" | \
          docker login --username AWS --password-stdin "${{ steps.acct.outputs.id }}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Build production image
        if: ${{ steps.can_deploy.outputs.should == 'true' }}
        run: docker build -t "${ECR_REPO}:${IMAGE_TAG}" -f Dockerfile.prod .

      - name: Tag & push image to ECR
        if: ${{ steps.can_deploy.outputs.should == 'true' }}
        run: |
          REG="${{ steps.acct.outputs.id }}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          docker tag "${ECR_REPO}:${IMAGE_TAG}" "${REG}/${ECR_REPO}:${IMAGE_TAG}"
          docker push "${REG}/${ECR_REPO}:${IMAGE_TAG}"

      - name: Generate Dockerrun.aws.json (ECS single container)
        if: ${{ steps.can_deploy.outputs.should == 'true' }}
        run: |
          REG="${{ steps.acct.outputs.id }}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          cat > Dockerrun.aws.json <<'JSON'
          {
            "AWSEBDockerrunVersion": 2,
            "containerDefinitions": [
              {
                "name": "nest-demo",
                "image": "__IMAGE__",
                "essential": true,
                "memoryReservation": 256,
                "portMappings": [{ "containerPort": 3000, "hostPort": 3000 }],
                "environment": [
                  { "name": "NODE_ENV", "value": "production" },
                  { "name": "PORT", "value": "3000" }
                ],
                "command": ["npm","run","prod"]
              }
            ]
          }
          JSON
          sed -i "s|__IMAGE__|${REG}/${ECR_REPO}:${IMAGE_TAG}|g" Dockerrun.aws.json

      - name: Create deployment package
        if: ${{ steps.can_deploy.outputs.should == 'true' }}
        run: zip -r dist.zip Dockerrun.aws.json

      - name: Deploy to Elastic Beanstalk (ECS platform)
        if: ${{ steps.can_deploy.outputs.should == 'true' }}
        uses: einaregilsson/beanstalk-deploy@v21
        with:
          aws_access_key: ${{ env.AWS_ACCESS_KEY }}
          aws_secret_key: ${{ env.AWS_SECRET_KEY }}
          application_name: ${{ env.EB_APP_NAME }}
          environment_name: ${{ env.EB_ENV_NAME }}
          region: ${{ env.AWS_REGION }}
          version_label: ${{ github.run_number }}-${{ github.sha }}
          use_existing_version_if_available: true
          deployment_package: "./dist.zip"
